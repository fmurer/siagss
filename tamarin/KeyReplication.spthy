/*
 *  Author: Fabian Murer
 *  Model Name: KeyReplication.spthy
 *  Status: DEVELOPMENTAL
 *
 *  Comments:
 */

theory KeyReplication
begin

builtins: asymmetric-encryption, signing
functions: 
	extract/2
equations: 
	extract(sign{m}skS, pk(skS)) = m


/*
 *
 * PKI
 *
 */

rule Register:
    [ Fr(~sk) ] 
  --> 
    [ !SecretKey($A, ~sk), !PublicKey($A, pk(~sk)), Out(pk(~sk)) ]

rule Reveal:
    [ !SecretKey(A, ltk) ]
  --[ Reveal(A) ]->
    [ Out(ltk) ]



/*
 *
 * Initialisation
 *
 */

rule Init_Replication:
    [ !SecretKey($R, skR), !PublicKey($V1, pkV1), !PublicKey($V2, pkV2) ]
  --[ Create($R, skR, 'Replication'), Diff(pkV1, pkV2), VerifierKeys(pkV1, pkV2) ]->
    [ St_R_1($R, skR, <pkV1, pkV2>) ]

rule Init_Verifier:
    [ !SecretKey($V, skV), !PublicKey($S, pkS), !PublicKey($R, pkR), Fr(~id) ]
  --[ Create($V, skV, 'Verifier'), ReplicationPublicKey(pkR), SignerPublicKey(pkS) ]->
    [ St_V_1($V, skV, pkS, pkR, ~id) ]

rule Init_Signer:
    [ !SecretKey($S, skS), !PublicKey($V1, pkV1), !PublicKey($V2, pkV2) ]
  --[ Create($S, skS, 'Signer'), Diff(pkV1, pkV2), VerifierKeys(pkV1, pkV2), FinishInit() ]->
    [ St_S_1($S, skS, <pkV1, pkV2>) ]


/*
 *
 * Protocol
 *
 */

// Stage 1: Verifier -> Signer

rule Verifier_Send_1:
  let
  	msg = sign{<pk(skR), id>}skV
  in
    [ St_V_1($V, skV, pk(skS), pk(skR), id) ]
  --[ Send($V, msg) ]->
    [ St_V_2($V, skV, pk(skS), pk(skR), id), Request(msg) ]


// Stage 2: Signer Check

rule Signer_Check:
    [ St_S_1($S, skS, <pk(skV1), pk(skV2)>), Request(sign{<pkR, id1>}skV1), Request(sign{<pkR, id2>}skV2) ]
  --[ Diff(id1, id2), Diff(skV1, skV2) ]->
    [ St_S_2($S, skS, <pk(skV1), pk(skV2)>, pkR) ]



// Stage 3: Signer -> Verifier

rule Signer_Send_3:
  let
  	enc = aenc{skS}pkR
  	response = sign{enc}skS
  in
    [ St_S_2($S, skS, <pk(skV1), pk(skV2)>, pkR) ]
  --[ Send($S, response), Secret(skS), Honest($S), Honest($R) ]->
    [ St_S_3($S, skS, <pk(skV1), pk(skV2)>, pkR), !SignerResponse(response) ]


// Stage 4: Verifier Check

rule Verifier_Check:
    [ St_V_2($V, skV, pk(skS), pk(skR), id), !SignerResponse(sign{enc}skS) ]
  -->
    [ St_V_3($V, skV, pk(skS), pk(skR), id, enc) ]



// Stage 5: Verifier -> Replication

rule Verifier_Send_5:
  let
  	response = sign{enc}skV
  in
    [ St_V_3($V, skV, pk(skS), pk(skR), id, enc) ]
  --[ Send($V, response) ]->
    [ St_V_4($V, skV, pk(skS), pk(skR), id), SignerKey(response) ]



// Stage 6: Replication Check

rule Replication_Check:
	let
		skS = skS1
	in
    [ St_R_1($R, skR, <pk(skV1), pk(skV2)>), SignerKey(sign{aenc{skS1}pk(skR)}skV1), SignerKey(sign{aenc{skS2}pk(skR)}skV2) ]
  --[ Equal(skS1, skS2), Diff(pk(skV1), pk(skV2)), Finish(), Secret(skS), Honest($R), Honest($S) ]->
    [ St_R_2($R, skR, <pk(skV1), pk(skV2)>, skS) ]


/*
 *
 * Properties to show
 *
 */

lemma executeability:
	exists-trace
		"Ex #i. Finish()@i"


lemma correctInit:
  exists-trace
  	"Ex S V R k1 k2 k3 #a #b #c #d. FinishInit()@a & Create(S, k1, 'Signer')@b & Create(V, k2, 'Verifier')@c & Create(R, k3, 'Replication')@d"


lemma SecretSigningKey:
	all-traces
	"All k #i. Secret(k)@i ==> (not(Ex #j. K(k)@j)) | (Ex B #j. Reveal(B)@j & Honest(B)@i)"

/*
 *
 * Restrictions that must hold
 *
 */

restriction VerifierPublicKeys:
  "All k1 k2 k3 k4 #a #b. (VerifierKeys(k1, k2)@a & VerifierKeys(k3, k4)@b & not(#a = #b)) ==>
  												(k1 = k3 & k2 = k4) &
  												(Ex V1 V2 sk1 sk2 #c #d. Create(V1, sk1, 'Verifier')@c & Create(V2, sk2, 'Verifier')@d & not(#c = #d) & k1 = pk(sk1) & k2 = pk(sk2))
  "

restriction NoSameSecretKeys:
	"All V1 V2 k1 k2 #a #b. Create(V1, k1, 'Verifier')@a & Create(V2, k2, 'Verifier')@b & not(#a = #b) ==> not(V1 = V2) & not(k1 = k2)"

restriction CorrectReplicationPublicKey:
  "All k1 #i. ReplicationPublicKey(k1)@i ==> (Ex R k2 #j. Create(R, k2, 'Replication')@j & k1 = pk(k2))"

restriction CorrectSignerPublicKey:
  "All k1 #i. SignerPublicKey(k1)@i ==> (Ex R k2 #j. Create(R, k2, 'Signer')@j & k1 = pk(k2))"


restriction Equal:
	"All x y #i. Equal(x, y)@i ==> x = y"

restriction Diff:
	"All x y #i. Diff(x, y)@i ==> not(x = y)"

restriction OnlyOneSigner:
	"All S1 S2 k1 k2 #i #j. Create(S1, k1, 'Signer')@i & Create(S2, k2, 'Signer')@j ==> #i = #j"

restriction OnlyOneReplication:
	"All S1 S2 k1 k2 #i #j. Create(S1, k1, 'Replication')@i & Create(S2, k2, 'Replication')@j ==> #i = #j"


end
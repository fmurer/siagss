/*
 *  Author: Fabian Murer
 *  Model Name: SignerInitialisation.spthy
 *  Status: DEVELOPMENTAL
 *
 *  Comments:
 */

theory SignerInitialisation_3
begin

builtins: signing, hashing
functions: 
  extract/2
equations: 
  extract(sign{m}skS, pk(skS)) = m


  
// Public key infrastructure

rule Register:
    [ Fr(~sk) ] 
  --> 
    [ !SecretKey($A, ~sk), !PublicKey($A, pk(~sk)), Out(pk(~sk)) ]

rule Reveal:
    [ !SecretKey(A, ltk) ]
  --[ Reveal(A) ]->
    [ Out(ltk) ]

rule Init_Config:
	[ Fr(~N), Fr(~t)]
  -->
  	[ !Config(~N, ~t) ]


// Initialisation

rule Init_Signer:
	[ !SecretKey($TPM, skTPM) ]
  --[ Create($S, 'Signer') ]->
	[ St_S_1($S, skTPM) ]

rule Init_Verifier:
	[ !SecretKey($V, skV), !PublicKey($TPM, pkTPM), !Config(N, t) ]
  --[ Create($V, 'Verifier'), TPM($V, pkTPM) ]->
	[ St_V_1($V, skV, pkTPM, <N, t>) ]



// Protocol

rule Verifier_Send_1:
  let
  	C = <N, t>
  	request = <C, pk(skV)>
  in
    [ St_V_1($V, skV, pk(skTPM), <N, t>) ]
  --[ Send($V, request) ]->
    [ St_V_2($V, skV, pk(skTPM), <N, t>), Init(request) ]


rule Signer_Receive_1:
  let
  	N = N1
  	t = t1
  in
    [ St_S_1($S, skTPM), Init(<<N1, t1>, pkV1>), Init(<<N2, t2>, pkV2>), Init(<<N3, t3>, pkV3>) ]
  --[ Equal(N1, N2), Equal(N2, N3), Equal(t1, t2), Equal(t2, t3), Diff(pkV1, pkV2) ]->
    [ St_S_2($S, skTPM, <pkV1, pkV2, pkV3>, <N, t>) ]



rule Signer_Send_2:
  let
  	response = sign{'ok'}skTPM
  in
    [ St_S_2($S, skTPM, <pkV1, pkV2, pkV3>, <N, t>), !SecretKey($S, skS) ]
  --[ Send($S, response), GenKey($S, skS) ]->
    [ St_S_3($S, skTPM, <pkV1, pkV2, pkV3>, <N, t>, skS), !OK(response) ]


rule Verifier_Receive_OK:
    [ St_V_2($V, skV, pk(skTPM), <N, t>), !OK(msg) ]
  --[ Equal(verify(msg, 'ok', pk(skTPM)), true) ]->
    [ St_V_3($V, skV, pk(skTPM), <N, t>) ]



rule Verifier_Send_Nonce:
	let
		toSend = sign{~nonce}skV
	in
    [ St_V_3($V, skV, pk(skTPM), <N, t>), Fr(~nonce) ]
  --[ Send($V, toSend) ]->
    [ St_V_4($V, skV, pk(skTPM), <N, t>, ~nonce), Out(toSend) ]




rule Signer_Receive_Nonce_1:
    [ St_S_3($S, skTPM, <pkV1, pkV2, pkV3>, <N, t>, skS), In(sign{nonce}skV) ]
  --[ Recv($S, nonce), Included(pk(skV), <pkV1, pkV2, pkV3>) ]->
    [ St_S_4($S, skTPM, <pkV1, pkV2, pkV3>, <pk(skV)>, <N, t>, skS, nonce) ]


rule Signer_Send_Anwer_1:
  let
  	C = <N, t>
  	lambda = <pkV1, pkV2, pkV3>
  	M = h(pk(skS), C, lambda)
  	signed = sign{nonce, M}skTPM
  	response = <~id, lambda, pk(skS), signed>
  in
    [ St_S_4($S, skTPM, <pkV1, pkV2, pkV3>, <pk1>, <N, t>, skS, nonce), Fr(~id)]
  --[ Send($S, response) ]->
    [ St_S_5($S, skTPM, <pkV1, pkV2, pkV3>, <pk1>, <N, t>, skS), Out(response) ]


rule Signer_Receive_Nonce_2:
    [ St_S_5($S, skTPM, <pkV1, pkV2, pkV3>, <pk1>, <N, t>, skS), In(sign{nonce}skV) ]
  --[ Recv($S, nonce), Included(pk(skV), <pkV1, pkV2, pkV3>), Diff(pk1, pk(skV)) ]->
    [ St_S_6($S, skTPM, <pkV1, pkV2, pkV3>, <pk1, pk(skV)>, <N, t>, skS, nonce) ]


rule Signer_Send_Anwer_2:
  let
    C = <N, t>
    lambda = <pkV1, pkV2, pkV3>
    M = h(pk(skS), C, lambda)
    signed = sign{nonce, M}skTPM
    response = <~id, lambda, pk(skS), signed>
  in
    [ St_S_6($S, skTPM, <pkV1, pkV2, pkV3>, <pk1, pk2>, <N, t>, skS, nonce), Fr(~id)]
  --[ Send($S, response) ]->
    [ St_S_7($S, skTPM, <pkV1, pkV2, pkV3>, <pk1, pk2>, <N, t>, skS), Out(response) ]


rule Signer_Receive_Nonce_3:
    [ St_S_7($S, skTPM, <pkV1, pkV2, pkV3>, <pk1, pk2>, <N, t>, skS), In(sign{nonce}skV) ]
  --[ Recv($S, nonce), Included(pk(skV), <pkV1, pkV2, pkV3>), Diff(pk1, pk(skV)), Diff(pk2, pk(skV)) ]->
    [ St_S_8($S, skTPM, <pkV1, pkV2, pkV3>, <pk1, pk2, pk(skV)>, <N, t>, skS, nonce) ]


rule Signer_Send_Anwer_3:
  let
    C = <N, t>
    lambda = <pkV1, pkV2, pkV3>
    M = h(pk(skS), C, lambda)
    signed = sign{nonce, M}skTPM
    response = <~id, lambda, pk(skS), signed>
  in
    [ St_S_8($S, skTPM, <pkV1, pkV2, pkV3>, <pk1, pk2, pk3>, <N, t>, skS, nonce), Fr(~id)]
  --[ Send($S, response) ]->
    [ St_S_9($S, skTPM, <pkV1, pkV2, pkV3>, <N, t>, skS), Out(response) ]




rule Verifier_Receive_Final:
  let
  	C = <N, t>
    lambda = <pkV1, pkV2, pkV3>
    signature = sign{nonce_new, h(pkS, C, lambda)}skTPM
  in
    [ St_V_4($V, skV, pk(skTPM), <N, t>, nonce), In(<id, lambda, pkS, signature>) ]
  --[ Recv($V, <id, lambda, pkS, signature>), Equal(nonce, nonce_new), Included(pk(skV), <pkV1, pkV2, pkV3>), Finish($V, pkS) ]->
    [ St_V_5($V, skV, pk(skTPM), <N, t>, nonce, id, pkS, <pkV1, pkV2, pkV3>) ]



// properties

lemma exists:
	exists-trace
  //"Ex S V sks #i #j. GenKey(S, sks)@i & Finish(V, pk(sks))@j & #i < #j"
  //"All V #i. Create(V, 'Verifier')@i ==> (Ex S sks #m #n. GenKey(S, sks)@m & Finish(V, pk(sks))@n & #m < #n)"
  "Ex V1 V2 V3 S sks #a #b #c #d. GenKey(S, sks)@a & Finish(V1, pk(sks))@b
                                                   & Finish(V2, pk(sks))@c
                                                   & Finish(V3, pk(sks))@d
                                                   & not (V1 = V2) & not(V1 = V3) & not(V2 = V3)
                                                   & #a < #b & #a < #c & #a < #d"


// restrictions

restriction Equal:
  "All x y #i. Equal(x, y)@i ==> x = y"

restriction Diff:
	" All x y #i. Diff(x, y)@i ==> not(x = y) "

restriction SameTPM:
 	" All V1 V2 tpm1 tpm2 #i #j. TPM(V1, tpm1)@i & TPM(V2, tpm2)@j & not(#i = #j) ==> tpm1 = tpm2 & not(V1 = V2)"

restriction OnlyOneSigner:
	" All S1 S2 id1 id2 #i #j. Create(S1, id1, 'Signer')@i& Create(S2, id2, 'Signer')@j ==> #i = #j "

restriction Included:
  "All p1 p2 p3 p4 #i. Included(p1, <p2, p3, p4>)@i ==> p1 = p2 | p1 = p3 | p1 = p4"


end
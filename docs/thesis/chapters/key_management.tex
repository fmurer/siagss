\chapter{Key Management}\label{chapter:key_management}
In this chapter we want to describe how the system handles the different keys used for signing and authentication. To start with, let us explain what keys the system is actually using. All the keys explained in the following sections are saved in the local file system using the principle of least privilege.

% TODO: The following should be somehow included
% - how to store the files (permission etc.)
% - usage of TPM like in CASTLE
% - other protection mechanisms

\section{Authentication}
In order to prevent an unauthorised signing request getting signed by the Signer, we authenticate the incoming requests at the Signee. In \autoref{subsec:signee} we have already mentioned that we use the \texttt{HMAC} module from the crypto library of Node.js for this. To compute the \texttt{HMAC} of the received data and later verify it at the Signer, the Signee and the Singer need to have a shared secret.

This shared secret is computed using a \emph{Elliptic Curve Diffie-Hellman} (ECDH) key exchange, which is supported by the crypto library of Node.js. We chose this algorithm over the standard Diffie-Hellman (DH) (which is also supported by Node.js), because ECDH is much faster than the standard DH used in Node.js. In ECDH we use the \emph{secp521r1} curve. In order to exchange the DH half-keys, we use the air-gapped channel, i.e., encode them to a QR-code and display it on the screen. Once having both half-keys, the Signee and the Signer can compute the shared secret (let's call it $sk$ for now).

Now in order to compute the authentication token of the received request, the Signee generates a \texttt{HMAC} using the \texttt{SHA256} algorithm together with the previously computed shared key $sk$.

We call the just described shared key establishment process \emph{pairing} the two systems. In the very first initialisation phase, i.e., when setting up the environment, the two DH half-keys are not authenticated when sending over the air-gapped channel. We argue that this can be handled since the setup needs to be done manually by a qualified administrator, so no malicious QR-code can be injected between the two systems. In later pairing steps, initiated by the Signee, the currently used shared key is used for authenticating the DH half-keys. Once the new shared key is established, the old one gets replaced.

\section{Signing}
As mentioned in \autoref{sec:components}, we use the \texttt{TweetNaCl} library from \citet{tweetnacl} to sign the received requests. The library includes a method to generate new random key pairs. The keys have the following sizes:

\begin{description}
\item[Public Key:] $256 bits$
\item[Secret Key:] $512 bits$
\end{description}

In the initialisation phase, the Signee needs to know the Signers public key, therefore the public key needs to be placed on the Signee. On the very first boot up of the Signee, it immediately asks the Signer for a \emph{key schedule}.

\begin{description}
\item[Key Schedule:] In our context, a \emph{key schedule} describes a list of public keys together with their validity ranges. You can find an example in \autoref{fig:key_schedule}. Thereby, the public keys are \texttt{hex} encoded.
\end{description}

\begin{code}[captionpos=b, caption={Example of a Key Schedule of length $3$},label={fig:key_schedule}]
{ 
  keys:
   { key1:
      { valid_from: 'Thu Jan 04 2018 09:52:15 GMT+0100 (CET)',
        valid_to: 'Thu Jan 04 2018 09:52:15 GMT+0100 (CET)',
        public_key: 'PUBLIC_KEY_1' },
     key2:
      { valid_from: 'Thu Jan 04 2018 09:54:15 GMT+0100 (CET)',
        valid_to: 'Thu Jan 04 2018 09:56:15 GMT+0100 (CET)',
        public_key: 'PUBLIC_KEY_2' },
     key3:
      { valid_from: 'Thu Jan 04 2018 09:56:15 GMT+0100 (CET)',
        valid_to: 'Thu Jan 04 2018 09:58:15 GMT+0100 (CET)',
        public_key: 'PUBLIC_KEY_3' }
    },
  signature: 'SIGNATURE'
}
\end{code}

Notice that the key schedule needs to be signed, otherwise an adversary could inject his own key schedule and the Signee would simply accept it. In this example, the keys are valid for $2$ minutes. However, one can choose the validity range for his needs.

When the Signee receives a key schedule, he sets a new scheduled job for every key. Those jobs are executed exactly when the next key starts to be valid. Furthermore, a short amount of time before the last key expires (in this case it is 30 seconds), the Signee asks for a new key schedule. The same key renewal rule is also applied at the Signer, i.e., when he creates a new key schedule, he also sets new scheduled jobs which fetch the new signing key from the list. All those time spans mentioned can be chosen arbitrarily. However, one should make sure that they match the specification of the system where the keys are integrated in. For example, the recommended usage period of a core AS key in the SCION architecture \cite{scion_book} is \emph{6 months}.




